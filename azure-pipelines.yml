trigger:
  branches:
    include:
    - main

pr:
  branches:
    include:
    - main

resources:
  - repo: self

variables:
  backendImageName: 'legis-vue-backend'
  frontendImageName: 'legis-vue-frontend'
  tag: '$(Build.BuildId)'
  vmImageName: 'ubuntu-latest'
  azureSubscription: 'da3b208d-e23d-4e3b-8901-1ee297dd91f0'
  containerRegistry: 'moregroupdev.azurecr.io'
  resourceGroupName: 'rg-legislation-tracker'
  backendContainerAppName: 'legis-vue-backend'
  frontendContainerAppName: 'legis-vue-frontend'
  keyVaultName: 'kv-legislation-tracker'

stages:
- stage: Test
  displayName: Run Tests
  jobs:
  - job: PlaywrightTests
    displayName: Run Playwright E2E Tests
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: NodeTool@0
      displayName: 'Install Node.js'
      inputs:
        versionSpec: '18.x'

    - script: |
        cd frontend
        npm ci
      displayName: 'Install frontend dependencies'

    - script: |
        cd frontend
        npx playwright install --with-deps
      displayName: 'Install Playwright browsers'

    - script: |
        cd frontend
        npm run dev &
        DEV_PID=$!
        echo "Started dev server with PID: $DEV_PID"

        # Wait for dev server to be ready
        echo "Waiting for dev server to be ready..."
        for i in {1..30}; do
          if curl -s http://localhost:3000 > /dev/null; then
            echo "Dev server is ready!"
            break
          fi
          echo "Waiting... ($i/30)"
          sleep 2
        done

        # Run Playwright tests
        echo "Running Playwright tests..."
        npx playwright test
        TEST_EXIT_CODE=$?

        # Kill dev server
        echo "Stopping dev server..."
        kill $DEV_PID || true

        exit $TEST_EXIT_CODE
      displayName: 'Run Playwright tests'
      env:
        CI: true

    - task: PublishTestResults@2
      displayName: 'Publish test results'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'frontend/test-results/junit.xml'
        failTaskOnFailedTests: true

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Playwright report'
      condition: succeededOrFailed()
      inputs:
        targetPath: 'frontend/playwright-report'
        artifact: 'playwright-report'
        publishLocation: 'pipeline'

- stage: Build
  displayName: Build and Push
  dependsOn: Test
  condition: succeeded()
  jobs:
  - job: BuildBackend
    displayName: Build Backend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: Build and Push Backend Image
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Login to ACR
          az acr login --name moregroupdev
          
          # Build image with platform specification
          docker build --platform linux/amd64 -t $(containerRegistry)/$(backendImageName):$(tag) -t $(containerRegistry)/$(backendImageName):latest ./backend
          
          # Push image
          docker push $(containerRegistry)/$(backendImageName):$(tag)
          docker push $(containerRegistry)/$(backendImageName):latest

  - job: BuildFrontend
    displayName: Build Frontend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: NodeTool@0
      displayName: 'Install Node.js'
      inputs:
        versionSpec: '18.x'

    - script: |
        cd frontend
        echo "Current version: $(cat package.json | grep version | head -1)"
        node update-version.cjs $(Build.BuildId)
        echo "Updated version: $(cat package.json | grep version | head -1)"
      displayName: 'Update version number'

    - task: AzureCLI@2
      displayName: Build and Push Frontend Image
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Login to ACR
          az acr login --name moregroupdev

          # Build image with platform specification
          docker build --platform linux/amd64 -t $(containerRegistry)/$(frontendImageName):$(tag) -t $(containerRegistry)/$(frontendImageName):latest ./frontend

          # Push image
          docker push $(containerRegistry)/$(frontendImageName):$(tag)
          docker push $(containerRegistry)/$(frontendImageName):latest

- stage: Deploy
  displayName: Deploy to Container Apps
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: DeployBackend
    displayName: Deploy Backend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: Deploy Backend to Container App
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Update container app with new image
          echo "Updating backend container app with new image..."
          az containerapp update \
            --name $(backendContainerAppName) \
            --resource-group $(resourceGroupName) \
            --container-name $(backendContainerAppName) \
            --image $(containerRegistry)/$(backendImageName):$(tag) \
            --set-env-vars "PYTHONUNBUFFERED=1"
          
          # Clear existing environment variables except for the ones we just set
          echo "Configuring backend environment variables..."
          
          # Function to add Key Vault reference
          add_keyvault_ref() {
            local ENV_NAME=$1
            local SECRET_NAME=$2
            
            echo "Setting $ENV_NAME from Key Vault secret $SECRET_NAME"
            az containerapp update \
              --name $(backendContainerAppName) \
              --resource-group $(resourceGroupName) \
              --set-env-vars "$ENV_NAME=secretref:https://$(keyVaultName).vault.azure.net/secrets/$SECRET_NAME"
          }

          # Add Key Vault references for each environment variable
          add_keyvault_ref "FRONTEND_URL" "FRONTEND-URL"
          add_keyvault_ref "AZURE_ENDPOINT" "AZURE-ENDPOINT"
          add_keyvault_ref "AZURE_KEY" "AZURE-KEY"
          add_keyvault_ref "AZURE_MODEL_NAME" "AZURE-MODEL-NAME"
          add_keyvault_ref "AZURE_SQL_DATABASE" "AZURE-SQL-DATABASE"
          add_keyvault_ref "AZURE_SQL_PASSWORD" "AZURE-SQL-PASSWORD"
          add_keyvault_ref "AZURE_SQL_SERVER" "AZURE-SQL-SERVER"
          add_keyvault_ref "AZURE_SQL_USERNAME" "AZURE-SQL-USERNAME"
          add_keyvault_ref "AZURE_SUBSCRIPTION_ID" "AZURE-SUBSCRIPTION-ID"
          add_keyvault_ref "DEBUG_MODE" "DEBUG-MODE"
          add_keyvault_ref "ENVIRONMENT" "ENVIRONMENT"
          add_keyvault_ref "FROM_EMAIL" "FROM-EMAIL"
          add_keyvault_ref "LEGISCAN_API_KEY" "LEGISCAN-API-KEY"
          add_keyvault_ref "MANAGED_IDENTITY_CLIENT_ID" "MANAGED-IDENTITY-CLIENT-ID"
          add_keyvault_ref "SENDGRID_API_KEY" "SENDGRID-API-KEY"
          add_keyvault_ref "SQL_ECHO" "SQL-ECHO"
          add_keyvault_ref "VITE_API_URL" "VITE-API-URL"
          add_keyvault_ref "VITE_API_URL_PROD" "VITE-API-URL-PROD"
          add_keyvault_ref "VITE_AZURE_CLIENT_ID" "VITE-AZURE-CLIENT-ID"
          add_keyvault_ref "VITE_AZURE_TENANT_ID" "VITE-AZURE-TENANT-ID"

          echo "Backend container app updated successfully."

  - job: DeployFrontend
    displayName: Deploy Frontend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: Deploy Frontend to Container App
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Update container app with new image
          echo "Updating frontend container app with new image..."
          az containerapp update \
            --name $(frontendContainerAppName) \
            --resource-group $(resourceGroupName) \
            --container-name $(frontendContainerAppName) \
            --image $(containerRegistry)/$(frontendImageName):$(tag)
          
          # Clear existing environment variables
          echo "Configuring frontend environment variables..."
          
          # Function to add Key Vault reference
          add_keyvault_ref() {
            local ENV_NAME=$1
            local SECRET_NAME=$2
            
            echo "Setting $ENV_NAME from Key Vault secret $SECRET_NAME"
            az containerapp update \
              --name $(frontendContainerAppName) \
              --resource-group $(resourceGroupName) \
              --set-env-vars "$ENV_NAME=secretref:https://$(keyVaultName).vault.azure.net/secrets/$SECRET_NAME"
          }
          
          # Add Key Vault references for each environment variable
          add_keyvault_ref "FRONTEND_URL" "FRONTEND-URL"
          add_keyvault_ref "AZURE_ENDPOINT" "AZURE-ENDPOINT"
          add_keyvault_ref "AZURE_KEY" "AZURE-KEY"
          add_keyvault_ref "AZURE_MODEL_NAME" "AZURE-MODEL-NAME"
          add_keyvault_ref "AZURE_SQL_DATABASE" "AZURE-SQL-DATABASE"
          add_keyvault_ref "AZURE_SQL_PASSWORD" "AZURE-SQL-PASSWORD"
          add_keyvault_ref "AZURE_SQL_SERVER" "AZURE-SQL-SERVER"
          add_keyvault_ref "AZURE_SQL_USERNAME" "AZURE-SQL-USERNAME"
          add_keyvault_ref "DEBUG_MODE" "DEBUG-MODE"
          add_keyvault_ref "ENVIRONMENT" "ENVIRONMENT"
          add_keyvault_ref "FROM_EMAIL" "FROM-EMAIL"
          add_keyvault_ref "LEGISCAN_API_KEY" "LEGISCAN-API-KEY"
          add_keyvault_ref "MANAGED_IDENTITY_CLIENT_ID" "MANAGED-IDENTITY-CLIENT-ID"
          add_keyvault_ref "SENDGRID_API_KEY" "SENDGRID-API-KEY"
          add_keyvault_ref "SQL_ECHO" "SQL-ECHO"
          add_keyvault_ref "VITE_API_URL" "VITE-API-URL"
          add_keyvault_ref "VITE_API_URL_PROD" "VITE-API-URL-PROD"
          add_keyvault_ref "VITE_AZURE_CLIENT_ID" "VITE-AZURE-CLIENT-ID"
          add_keyvault_ref "VITE_AZURE_TENANT_ID" "VITE-AZURE-TENANT-ID"
          
          echo "Frontend container app updated successfully."
