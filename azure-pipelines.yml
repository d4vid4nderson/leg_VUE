trigger:
  branches:
    include:
    - main

pr:
  branches:
    include:
    - main

resources:
  - repo: self

variables:
  backendImageName: 'legis-vue-backend'
  frontendImageName: 'legis-vue-frontend'
  tag: '$(Build.BuildId)'
  vmImageName: 'ubuntu-latest'
  azureSubscription: 'da3b208d-e23d-4e3b-8901-1ee297dd91f0'
  containerRegistry: 'moregroupdev.azurecr.io'
  resourceGroupName: 'rg-legislation-tracker'
  backendContainerAppName: 'legis-vue-backend'
  frontendContainerAppName: 'legis-vue-frontend'
  keyVaultName: 'kv-legislation-tracker'
  # Note: All other variables are defined in the Azure DevOps UI with underscores
  # e.g., FRONTEND_URL, AZURE_ENDPOINT, etc.

stages:
- stage: Build
  displayName: Build and Push
  jobs:
  - job: BuildBackend
    displayName: Build Backend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: Build and Push Backend Image
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Login to ACR
          az acr login --name moregroupdev
          
          # Build image with platform specification
          docker build --platform linux/amd64 -t $(containerRegistry)/$(backendImageName):$(tag) -t $(containerRegistry)/$(backendImageName):latest ./backend
          
          # Push image
          docker push $(containerRegistry)/$(backendImageName):$(tag)
          docker push $(containerRegistry)/$(backendImageName):latest

  - job: BuildFrontend
    displayName: Build Frontend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: Build and Push Frontend Image
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Login to ACR
          az acr login --name moregroupdev
          
          # Build image with platform specification
          docker build --platform linux/amd64 -t $(containerRegistry)/$(frontendImageName):$(tag) -t $(containerRegistry)/$(frontendImageName):latest ./frontend
          
          # Push image
          docker push $(containerRegistry)/$(frontendImageName):$(tag)
          docker push $(containerRegistry)/$(frontendImageName):latest

- stage: Deploy
  displayName: Deploy to Container Apps
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: DeployBackend
    displayName: Deploy Backend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: Deploy Backend to Container App
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Update container app with new image
          echo "Updating backend container app with new image..."
          az containerapp update \
            --name $(backendContainerAppName) \
            --resource-group $(resourceGroupName) \
            --container-name $(backendContainerAppName) \
            --image $(containerRegistry)/$(backendImageName):$(tag)
          
          # Add environment variables directly to the container app
          echo "Configuring backend environment variables..."
          
          # Set all variables directly (using variables with underscores as defined in Azure DevOps UI)
          az containerapp update \
            --name $(backendContainerAppName) \
            --resource-group $(resourceGroupName) \
            --set-env-vars \
            "ENVIRONMENT=$(ENVIRONMENT)" \
            "AZURE_ENDPOINT=$(AZURE_ENDPOINT)" \
            "AZURE_KEY=$(AZURE_KEY)" \
            "AZURE_MODEL_NAME=$(AZURE_MODEL_NAME)" \
            "AZURE_SQL_SERVER=$(AZURE_SQL_SERVER)" \
            "AZURE_SQL_DATABASE=$(AZURE_SQL_DATABASE)" \
            "AZURE_SQL_USERNAME=$(AZURE_SQL_USERNAME)" \
            "AZURE_SQL_PASSWORD=$(AZURE_SQL_PASSWORD)" \
            "LEGISCAN_API_KEY=$(LEGISCAN_API_KEY)" \
            "FRONTEND_URL=$(FRONTEND_URL)" \
            "MANAGED_IDENTITY_CLIENT_ID=$(MANAGED_IDENTITY_CLIENT_ID)" \
            "DEBUG_MODE=$(DEBUG_MODE)" \
            "FROM_EMAIL=$(FROM_EMAIL)" \
            "SENDGRID_API_KEY=$(SENDGRID_API_KEY)" \
            "SQL_ECHO=$(SQL_ECHO)" \
            "VITE_API_URL=$(VITE_API_URL)" \
            "VITE_API_URL_PROD=$(VITE_API_URL_PROD)" \
            "VITE_AZURE_CLIENT_ID=$(VITE_AZURE_CLIENT_ID)" \
            "VITE_AZURE_TENANT_ID=$(VITE_AZURE_TENANT_ID)" \
            "PYTHONUNBUFFERED=1"
          
          echo "Backend container app updated successfully."

  - job: DeployFrontend
    displayName: Deploy Frontend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: Deploy Frontend to Container App
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Update container app with new image
          echo "Updating frontend container app with new image..."
          az containerapp update \
            --name $(frontendContainerAppName) \
            --resource-group $(resourceGroupName) \
            --container-name $(frontendContainerAppName) \
            --image $(containerRegistry)/$(frontendImageName):$(tag)
          
          # Add environment variables directly to the container app  
          echo "Configuring frontend environment variables..."
          
          # Set all variables directly (using variables with underscores as defined in Azure DevOps UI)
          az containerapp update \
            --name $(frontendContainerAppName) \
            --resource-group $(resourceGroupName) \
            --set-env-vars \
            "ENVIRONMENT=$(ENVIRONMENT)" \
            "FRONTEND_URL=$(FRONTEND_URL)" \
            "VITE_API_URL=$(VITE_API_URL)" \
            "VITE_API_URL_PROD=$(VITE_API_URL_PROD)" \
            "VITE_AZURE_CLIENT_ID=$(VITE_AZURE_CLIENT_ID)" \
            "VITE_AZURE_TENANT_ID=$(VITE_AZURE_TENANT_ID)"
          
          echo "Frontend container app updated successfully."

- stage: Test
  displayName: Test Deployed Environment
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: TestDeployedBackend
    displayName: Test Backend Connectivity
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: Prepare Test Script
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Wait for deployments to stabilize
          echo "Waiting for deployments to stabilize..."
          sleep 30
          
          # Create a one-time job that runs the test script
          echo "Creating a temporary job to run test_prod.py..."
          
          # Get the container image
          CONTAINER_IMAGE=$(az containerapp show \
            --name $(backendContainerAppName) \
            --resource-group $(resourceGroupName) \
            --query "properties.template.containers[0].image" \
            --output tsv)
          
          # Get the environment ID
          ENVIRONMENT_ID=$(az containerapp show \
            --name $(backendContainerAppName) \
            --resource-group $(resourceGroupName) \
            --query "properties.environmentId" \
            --output tsv)
          
          # Extract the environment name from the ID
          ENVIRONMENT_NAME=$(echo $ENVIRONMENT_ID | awk -F'/' '{print $NF}')
          
          echo "Container image: $CONTAINER_IMAGE"
          echo "Environment name: $ENVIRONMENT_NAME"
          
          # Create a job that runs the test script
          JOB_NAME="test-job-$(Build.BuildId)"
          echo "Creating job: $JOB_NAME"
          
          az containerapp job create \
            --name $JOB_NAME \
            --resource-group $(resourceGroupName) \
            --environment $ENVIRONMENT_NAME \
            --trigger-type Manual \
            --replica-timeout 300 \
            --replica-retry-limit 1 \
            --replica-completion-count 1 \
            --parallelism 1 \
            --image $CONTAINER_IMAGE \
            --cpu "0.5" \
            --memory "1Gi" \
            --command "python test_prod.py" \
            --env-vars "PYTHONUNBUFFERED=1" \
            --output json > job_creation.json
          
          # Start the job
          echo "Starting the test job..."
          az containerapp job start \
            --name $JOB_NAME \
            --resource-group $(resourceGroupName) \
            --output json > job_start.json
          
          # Wait for the job to complete (poll status)
          echo "Waiting for job to complete..."
          MAX_ATTEMPTS=30
          ATTEMPT=0
          SLEEP_TIME=10
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            # Get the latest execution
            az containerapp job execution list \
              --name $JOB_NAME \
              --resource-group $(resourceGroupName) \
              --output json > job_executions.json
            
            # Check if there's a completed execution
            EXECUTION_NAME=$(cat job_executions.json | jq -r '.[0].name')
            STATUS=$(cat job_executions.json | jq -r '.[0].properties.status')
            
            echo "Execution: $EXECUTION_NAME, Status: $STATUS"
            
            if [[ "$STATUS" == "Succeeded" || "$STATUS" == "Failed" ]]; then
              break
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            echo "Waiting for job completion... Attempt $ATTEMPT of $MAX_ATTEMPTS"
            sleep $SLEEP_TIME
          done
          
          # Get the logs
          echo "Getting logs for execution: $EXECUTION_NAME"
          az containerapp job execution logs \
            --name $JOB_NAME \
            --resource-group $(resourceGroupName) \
            --execution-name $EXECUTION_NAME > test_logs.txt
          
          # Display the logs
          echo "=== TEST RESULTS ==="
          cat test_logs.txt
          
          # Check for success indicators in the logs
          if grep -q "All tests completed" test_logs.txt && grep -q "✅" test_logs.txt; then
            echo "✅ Test script ran successfully!"
            exit 0
          else
            echo "❌ Test script failed or had errors."
            exit 1
          fi
